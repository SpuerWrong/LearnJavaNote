# Java_方法

## 什么是方法
在Java中，方法是一组用于执行某一特定功能的代码片段。比如 `System.out.println()`，其中 `System` 是一个类，`out` 是 `System` 类的一个对象，而 `println` 就是一个方法。方法可以让代码更加模块化，便于复用和维护。

Java中的**方法**可以理解为一系列语句的集合，用来实现某个功能。方法的设计原则如下：
- 方法的本意是功能块，表示实现某一特定功能的代码块。
- 一个方法应该只完成一个功能，这样可以提高代码的可维护性和可扩展性。
- 方法必须包含在类或对象中。
- 命名规则：方法名应以小写字母开头，使用驼峰命名法（例如 `calculateSum`）。
- `main()` 方法要尽量保持简洁明了。

例如：
```java
public class LearnMethod01 {
    public static void main(String[] args) {
        int sum = add(1, 2);
        System.out.println(sum);
    }

    // 定义一个求和的方法
    public static int add(int a, int b) {
        return a + b;
    }
}
```

---

## 方法的定义
在Java中，方法类似于其他编程语言中的函数，是一段用于完成特定功能的代码片段。定义一个方法的基本语法如下：
```java
修饰符 返回值类型 方法名(参数类型 参数名) {
    方法体
    return 返回值;
}
```
- **方法头**：包含修饰符、返回值类型、方法名和参数列表。
- **修饰符**：可选，通常用于指定方法的访问权限（如 `public`、`private` 等）。
- **返回值类型**：方法的返回类型，若没有返回值则用 `void` 表示。
- **方法名**：定义方法的名称，通常遵循驼峰命名法。
- **参数类型和参数名**：指定方法接受的参数类型和名称，参数名用于方法内部使用。
- **方法体**：包含具体的代码，用于实现方法的功能。
- **返回值**：通过 `return` 语句返回结果，若方法无返回值则不需要 `return`。

例如：
```java
public static int max(int a, int b) {
    if (a == b) {
        return 0;  // 返回0，并且终止方法的执行
    }
    return (a > b) ? a : b;  // 返回较大的值
}
```

---

## 方法重载
**方法重载**是指在同一个类中可以定义多个相同名称的方法，只要它们的参数列表不同即可。方法重载的主要规则是：
- 方法名必须相同。
- 参数列表必须不同（参数的类型、个数、顺序之一不同）。
- 方法的返回类型可以相同或不同，但返回类型不能作为重载的唯一依据。

例如：
```java
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double b) {
    return a + b;
}
```
在上面的例子中，`add` 方法被重载了两次，分别用于处理整数和浮点数的加法运算。

---

## 命令行传参
（了解即可）在运行一个Java程序时，可以通过命令行参数将数据传递给 `main()` 方法。`main()` 方法的参数是一个字符串数组，用来接收命令行传入的参数。

---

## 可变传参
从JDK 1.5开始，Java支持在方法中使用可变长度参数。可变参数允许你传递任意数量的同类型参数给方法。
- 可变参数通过在参数类型后面加 `...` 表示。
- 一个方法只能有一个可变参数，且该参数必须是方法的最后一个参数。

例如：
```java
public static void printNumbers(int... numbers) {
    for (int number : numbers) {
        System.out.println(number);
    }
}
```
调用该方法时可以传入任意数量的整数：
```java
printNumbers(1, 2, 3, 4);  // 输出1到4
```

---

## 递归
**递归**指的是一个方法调用自身。递归通常用于解决那些可以通过将问题分解为更小的相同问题来处理的场景。递归的核心思想是将复杂问题转化为更简单的问题层层求解。

递归方法通常包括两部分：
1. **递归头**：终止递归的条件。如果没有递归头，递归将一直执行下去，导致栈溢出。
2. **递归体**：包含调用自身的部分。

递归的优点是可以用简洁的代码实现复杂的逻辑，但递归深度过大可能会导致栈内存不足，出现栈溢出问题。

一个经典的递归例子是计算阶乘：
```java
public static int factorial(int n) {
    if (n == 1) {  // 递归头，终止递归的条件
        return 1;
    } else {
        return n * factorial(n - 1);  // 递归体，调用自身
    }
}
```
在这个例子中，`factorial(5)` 会递归调用自身，直到 `n == 1`，最后返回阶乘的结果。递归的调用链如下：
```
factorial(5) = 5 * factorial(4)
factorial(4) = 4 * factorial(3)
factorial(3) = 3 * factorial(2)
factorial(2) = 2 * factorial(1)
factorial(1) = 1
```
因此，`factorial(5)` 的结果为 `5 * 4 * 3 * 2 * 1 = 120`。

递归虽然强大，但如果递归层数过深，可能会导致栈溢出（即内存不足来存储递归调用），所以递归策略适合处理规模较小的问题。

---


